###We don't want to make comparisons of WT to itself - this could impact FDR correction
indiv_data <- data_frame%>%
group_by(Measurement, Experiment)%>%
###Create a column with the number of WT individual plants and the number of plants for each genotype
###Use this later to calculate effect size
mutate(p = (wilcox.test(NormalizedMeasuredValue[Genotype == i], NormalizedMeasuredValue[Genotype == "Col0"], correct = FALSE, paired = FALSE))$p.value)%>%
###Add a column with each genotype
mutate(Genotype = i)%>%
# mutate(number = unique(filter(feb_data, genotype == i)$number))%>%
# mutate(number_2 = unique(filter(feb_data, genotype == i)$number_2))%>%
#
select(Experiment, Genotype, Measurement, p)
###Add individual information to the main data frame
out <- rbind(as.data.frame(indiv_data), out)}
return(out)}
p_value(NormalizedData)
p_value <- function (data_frame){
###Initialize an empty data frame
out = data.frame()
###For each genotype:
for (i in unique(filter(data_frame, Genotype != "Col" & Genotype != "mpk5_17")$Genotype)){
###We don't want to make comparisons of WT to itself - this could impact FDR correction
indiv_data <- data_frame%>%
group_by(Measurement, Experiment)%>%
###Create a column with the number of WT individual plants and the number of plants for each genotype
###Use this later to calculate effect size
mutate(p = (wilcox.test(NormalizedMeasuredValue[Genotype == i], NormalizedMeasuredValue[Genotype == "Col0"], correct = FALSE, paired = FALSE))$p.value)%>%
###Add a column with each genotype
mutate(Genotype = i)%>%
# mutate(number = unique(filter(feb_data, genotype == i)$number))%>%
# mutate(number_2 = unique(filter(feb_data, genotype == i)$number_2))%>%
#
select(Experiment, Genotype, Measurement, p)
###Add individual information to the main data frame
out <- rbind(as.data.frame(indiv_data), out)}
return(out)}
p_value(NormalizedData)
p_value <- function (data_frame){
###Initialize an empty data frame
out = data.frame()
###For each genotype:
for (i in unique(filter(data_frame, Genotype != "Col")$Genotype)){
###We don't want to make comparisons of WT to itself - this could impact FDR correction
indiv_data <- data_frame%>%
group_by(Measurement, Experiment)%>%
###Create a column with the number of WT individual plants and the number of plants for each genotype
###Use this later to calculate effect size
mutate(p = (wilcox.test(NormalizedMeasuredValue[Genotype == i], NormalizedMeasuredValue[Genotype == "Col0"], correct = FALSE, paired = FALSE))$p.value)%>%
###Add a column with each genotype
mutate(Genotype = i)%>%
# mutate(number = unique(filter(feb_data, genotype == i)$number))%>%
# mutate(number_2 = unique(filter(feb_data, genotype == i)$number_2))%>%
#
select(Experiment, Genotype, Measurement, p)
###Add individual information to the main data frame
out <- rbind(as.data.frame(indiv_data), out)}
return(out)}
p_value(NormalizedData)
Test <- NormalizedData%>%filter(genotype == "mpk1")
Test <- NormalizedData%>%filter(Genotype == "mpk1")
p_value(Test)
Test
unique(Test$Genotype)
View(Test)
p_value <- function (data_frame){
###Initialize an empty data frame
out = data.frame()
###For each genotype:
for (i in unique(filter(data_frame, Genotype != "Col")$Genotype)){
###We don't want to make comparisons of WT to itself - this could impact FDR correction
indiv_data <- data_frame%>%
group_by(Measurement, Experiment)%>%
###Create a column with the number of WT individual plants and the number of plants for each genotype
###Use this later to calculate effect size
mutate(p = (wilcox.test(NormalizedMeasuredValue[Genotype == i], NormalizedMeasuredValue[Genotype == "Col0"], correct = FALSE, paired = FALSE))$p.value)%>%
###Add a column with each genotype
mutate(Genotype = i)%>%
# mutate(number = unique(filter(feb_data, genotype == i)$number))%>%
# mutate(number_2 = unique(filter(feb_data, genotype == i)$number_2))%>%
#
select(Experiment, Genotype, Measurement, p)
###Add individual information to the main data frame
out <- rbind(as.data.frame(indiv_data), out)}
return(out)}
p_value(NormalizedData)
filter(NormalizedData, Measurement == "SN", Experiment == "DEPI1")
filter(NormalizedData, Measurement == "SN", Experiment == "DEPI1")%>%summarize(length(unique(Genotype)))
filter(NormalizedData, Measurement == "SN", Experiment == "DEPI1")%>%group_by(Genotype)%>%tally()
filter(NormalizedData, Measurement == "SN", Experiment == "DEPI1")%>%group_by(Genotype)%>%tally()%>%print(n = 100)
p_value <- function (data_frame){
###Initialize an empty data frame
out = data.frame()
###For each genotype:
for (i in unique(filter(data_frame, Genotype != "Col")$Genotype)){
###We don't want to make comparisons of WT to itself - this could impact FDR correction
indiv_data <- data_frame%>%
group_by(Measurement, Experiment)%>%
###Create a column with the number of WT individual plants and the number of plants for each genotype
###Use this later to calculate effect size
mutate(p = (wilcox.test(NormalizedMeasuredValue[Genotype == i], NormalizedMeasuredValue[Genotype == "Col"], correct = FALSE, paired = FALSE))$p.value)%>%
###Add a column with each genotype
mutate(Genotype = i)%>%
# mutate(number = unique(filter(feb_data, genotype == i)$number))%>%
# mutate(number_2 = unique(filter(feb_data, genotype == i)$number_2))%>%
#
select(Experiment, Genotype, Measurement, p)
###Add individual information to the main data frame
out <- rbind(as.data.frame(indiv_data), out)}
return(out)}
NormalizedData <- as.data.frame(NormalizedData)
p_value(NormalizedData)
warnings()
out <- p_value(NormalizedData)
out
p_value <- function (data_frame){
###Initialize an empty data frame
out = data.frame()
###For each genotype:
for (i in unique(filter(data_frame, Genotype != "Col")$Genotype)){
###We don't want to make comparisons of WT to itself - this could impact FDR correction
indiv_data <- data_frame%>%
group_by(Measurement, Experiment)%>%
###Create a column with the number of WT individual plants and the number of plants for each genotype
###Use this later to calculate effect size
mutate(p = (wilcox.test(NormalizedMeasuredValue[Genotype == i], NormalizedMeasuredValue[Genotype == "Col"], correct = FALSE, paired = FALSE))$p.value)%>%
###Add a column with each genotype
mutate(Genotype = i)%>%
# mutate(number = unique(filter(feb_data, genotype == i)$number))%>%
# mutate(number_2 = unique(filter(feb_data, genotype == i)$number_2))%>%
#
select(Experiment, Genotype, Measurement, p)
###Add individual information to the main data frame
out <- rbind(as.data.frame(indiv_data), out)}
return(out)}
NormalizedData <- as.data.frame(NormalizedData)
out <- p_value(NormalizedData)
NormalizedData%>%group_by(Measurement, Experiment)%>%mutate(a = mean(NormalizedMeasuredValue[Genotype == i]))
rm(list = ls())
for (i in c("DEPI1", "DEPI2", "DEPI3")){
for (m in c("TSC", "SN", "SPF")){
plotData <- NormalizedData%>%
filter(Measurement == m , Experiment == i)
title1 <- paste(i, m, "- Before Normalization", sep = " ")
title2 <- paste(i, m, "- After Normalization", sep = " ")
plot1 <- ggplot(data = plotData, aes(x = Measured_Value, color = Flat))+
geom_density()+
stat_density(geom = "line", position = "identity")+
theme_linedraw()+
labs(x = m,
y = "Density",
title = title1)
plot2 <- ggplot(data = plotData, aes(x = NormalizedMeasuredValue, color = Flat))+
geom_density()+
stat_density(geom = "line", position = "identity")+
theme_linedraw()+
labs(x = paste(m ,"Normalized by Flat", sep = " "),
y = "Density",
title = title2)
grid.arrange(plot1, plot2)
# ggsave(file=QuantFileName, arrangeGrob(plot1, plot2), width = 7, height = 7)
}
}
### This code creates an excel file of the normalized values and
### doesn't remove the outliers
###Load Necessary Packages
library(ggplot2)
library(gridExtra)
library(stringr)
library(dplyr)
library(preprocessCore)
library(Routliers)
library(tidyr)
library(ggthemes)
library(extrafont)
data <- read.csv("C:/Users/Owner/Documents/Research/Shiu_Lab/Shiu_Lab_R/Data/MAPK_DEPI_fitness_data_110920.csv", header = TRUE)
###The "Experiment" column name reads in strange, with weird characters at the begining
###Rename this column:
colnames(data)[1] <- "Experiment"
#Make sure flat, row, column, and genotype are coded as categorical variables
data$Flat<-as.factor(data$Flat)
data$Row<-as.factor(data$Row)
data$Column<-as.factor(data$Column)
data$Genotype <- as.factor(data$Genotype)
data <- data%>%
###Group by experiment and genotype
group_by(Experiment, Genotype)%>%
###INCLUDE THE OUTLIER REMOVAL STEPS HERE:
###For each of the measurements, replace the measured value with NA if the measured value is classified as an outlier
mutate(SN = replace(SN, outliers_mad(SN, b=1.4826, threshold=3.5, na.rm=TRUE)$outliers_pos, NA))%>%
mutate(SPF = replace(SPF, outliers_mad(SPF, b=1.4826, threshold=3.5, na.rm=TRUE)$outliers_pos, NA))%>%
mutate(TSC = replace(TSC, outliers_mad(TSC, b=1.4826, threshold=3.5, na.rm=TRUE)$outliers_pos, NA))%>%
ungroup()%>%
###Rearrange the data by experiment and genotype
arrange(Experiment, Genotype)
###Here, summarize the proportion of measured values that are classified as outliers for each measurement:
###TSC
###THIS CODE IS UNNECESSARY; WE DIDN'T REMOVE OUTLIERS HERE
data%>%
group_by(Experiment)%>%
summarize(PropOutlier = sum(is.na(TSC)) / length(TSC))
###SPF
data%>%
group_by(Experiment)%>%
summarize(PropOutlier = sum(is.na(SPF)) / length(SPF))
###SN
data%>%
group_by(Experiment)%>%
summarize(PropOutlier = sum(is.na(SN)) / length(SN))
###Generally, DEPI2 has more outliers than the other two experiments
###Leaning towards not showing SPF - focus on SN and TSC
###See which ones are thrown out
#Get a list of the double mutants in this data frame:
all_double_mutants = list()
for (gen in levels(data$Genotype)) {
if (str_detect(gen, "_") == T) {
all_double_mutants = c(all_double_mutants, gen)
}
}
###This function allows us to create a data frame where the columns are different lengths
###This is needed, because there are a different number of plants per flat
###To achieve this, add NA to the end of each column until each column is the same length
addToDF <- function(df, v){
nRow <- nrow(df)
lngth <- length(v)
if(nRow > lngth){
length(v) <- nRow
}else if(nRow < lngth){
df[(nRow+1):lngth, ] <- NA
}
cbind(df,v)
}
###Create a loop for each measurement and experiment
for (i in 8:10){
###Set the name to be either SN, SPF, or TSC, depending on the column
tmp.name <- colnames(data)[i]
###For each of the experiments:
for (j in c("DEPI1", "DEPI2", "DEPI3")){
###Filter to select each specific month
temp_vector <- filter(data, Experiment == j)
###Initialize an empty data frame
temp_df <- data.frame()
###Loop through each flat
for (k in 1:length(unique(temp_vector$Flat))){
###Create a temporary data frame - each column is the measured values for each flat
temp <- filter(temp_vector, Flat == k)[,i]
temp <- as.data.frame(temp)[,1]
temp_df <- addToDF(temp_df, temp)}
###Normalize across the flats
temp_normalize <- as.data.frame(normalize.quantiles(as.matrix(temp_df)))%>%
###Add columns with the measurement and experiment to be certain there hasn't been any mix-ups
mutate(col.number = i, experiment= j)
###Create a name to give the normalized data based on the measurement and experiment
temp_name <- paste(tolower(j), "_", tmp.name , "_normalize", sep = "")
###Rename the columns
###3 flats
if(ncol(temp_normalize) == 5){
temp_normalize <- temp_normalize%>%
rename(flat_1 = V1, flat_2 = V2, flat_3 = V3)
###4 flats
}else if (ncol(temp_normalize) == 6){
temp_normalize <- temp_normalize%>%
rename(flat_1 = V1, flat_2 = V2, flat_3 = V3, flat_4 = V4)
###5 flats
}else{
temp_normalize <- temp_normalize%>%
rename(flat_1 = V1, flat_2 = V2, flat_3 = V3, flat_4 = V4, flat_5 = V5)}
###Assign the name to the data frame
assign(temp_name, temp_normalize)}
}
###Replace the measured values with the quantile normalized measured values:
###First, start with a test so I know this is the correct method
###Filter to only include Flat 2 and DEPI1
test <- subset(data, Flat == 2 & Experiment == "DEPI1")
###Add a column with the normalized value
###These normalized values are the second column, with the string of NA
###values removed from the column
test$NormalizedSN <- depi1_SN_normalize[,2][1:132]
###Add a column with the count
test$Count <- 1:nrow(test)
###Sort first by quantile normalized value, and then by the un-normalized value
###Because the order is maintained when we quantile normalized, this should be the same data frame!
order1 <- test%>%
arrange(SN)
order2 <- test%>%
arrange(NormalizedSN)
order1 == order2
###Plan:
###Divide the data by Flat and Experiment
###Do the above approach
###Re-combine the data
###Reshape the data, so instead of having a column for each measurement, we
###have a column with the measurement type - either SN, TSC, or SPF
data <- data%>%
gather(Measurement, Measured_Value, 8:10)
###For each experiment and flat:
###Remove NA values from the data, and add a column with the normalized
###values to the data
DEPI1_SN <- data.frame()
for (i in 1:4){
tempFlat <- data%>%
filter(Flat == i, Experiment == "DEPI1", Measurement == "SN")
tempFlat <- na.omit(tempFlat)
tempFlat$NormalizedMeasuredValue <- na.omit(depi1_SN_normalize[,i])
DEPI1_SN <- rbind(DEPI1_SN, tempFlat)
}
DEPI1_TSC <- data.frame()
for (i in 1:4){
tempFlat <- data%>%
filter(Flat == i, Experiment == "DEPI1", Measurement == "TSC")
tempFlat <- na.omit(tempFlat)
tempFlat$NormalizedMeasuredValue <- na.omit(depi1_TSC_normalize[,i])
DEPI1_TSC <- rbind(DEPI1_TSC, tempFlat)
}
DEPI1_SPF <- data.frame()
for (i in 1:4){
tempFlat <- data%>%
filter(Flat == i, Experiment == "DEPI1", Measurement == "SPF")
tempFlat <- na.omit(tempFlat)
tempFlat$NormalizedMeasuredValue <- na.omit(depi1_SPF_normalize[,i])
DEPI1_SPF <- rbind(DEPI1_SPF, tempFlat)
}
DEPI2_SN <- data.frame()
for (i in 1:3){
tempFlat <- data%>%
filter(Flat == i, Experiment == "DEPI2", Measurement == "SN")
tempFlat <- na.omit(tempFlat)
tempFlat$NormalizedMeasuredValue <- na.omit(depi2_SN_normalize[,i])
DEPI2_SN <- rbind(DEPI2_SN, tempFlat)
}
DEPI2_TSC <- data.frame()
for (i in 1:3){
tempFlat <- data%>%
filter(Flat == i, Experiment == "DEPI2", Measurement == "TSC")
tempFlat <- na.omit(tempFlat)
tempFlat$NormalizedMeasuredValue <- na.omit(depi2_TSC_normalize[,i])
DEPI2_TSC <- rbind(DEPI2_TSC, tempFlat)
}
DEPI2_SPF <- data.frame()
for (i in 1:3){
tempFlat <- data%>%
filter(Flat == i, Experiment == "DEPI2", Measurement == "SPF")
tempFlat <- na.omit(tempFlat)
tempFlat$NormalizedMeasuredValue <- na.omit(depi2_SPF_normalize[,i])
DEPI2_SPF <- rbind(DEPI2_SPF, tempFlat)
}
DEPI3_SN <- data.frame()
for (i in 1:5){
tempFlat <- data%>%
filter(Flat == i, Experiment == "DEPI3", Measurement == "SN")
tempFlat <- na.omit(tempFlat)
tempFlat$NormalizedMeasuredValue <- na.omit(depi3_SN_normalize[,i])
DEPI3_SN <- rbind(DEPI3_SN, tempFlat)
}
DEPI3_TSC <- data.frame()
for (i in 1:5){
tempFlat <- data%>%
filter(Flat == i, Experiment == "DEPI3", Measurement == "TSC")
tempFlat <- na.omit(tempFlat)
tempFlat$NormalizedMeasuredValue <- na.omit(depi3_TSC_normalize[,i])
DEPI3_TSC <- rbind(DEPI3_TSC, tempFlat)
}
DEPI3_SPF <- data.frame()
for (i in 1:5){
tempFlat <- data%>%
filter(Flat == i, Experiment == "DEPI3", Measurement == "SPF")
tempFlat <- na.omit(tempFlat)
tempFlat$NormalizedMeasuredValue <- na.omit(depi3_SPF_normalize[,i])
DEPI3_SPF <- rbind(DEPI3_SPF, tempFlat)
}
###Combine all of these data frames into one with all normalized values
NormalizedData <- rbind(DEPI1_SN,
DEPI1_SPF,
DEPI1_TSC,
DEPI2_SN,
DEPI2_SPF,
DEPI2_TSC,
DEPI3_SN,
DEPI3_SPF,
DEPI3_TSC
)
### SAVE THESE NORMALIZED VALUES FOR MELISSA
### REMEMBER, THIS IS WITH REMOVING THE OUTLIERS
write.csv(NormalizedData, file = "Fitness_NormalizedValues_OutliersRemoved.csv")
###Visualize the normalizations to make sure the quantile normalized
###flats each have the same distribution for all experiments
p_value <- function (data_frame){
###Initialize an empty data frame
out = data.frame()
###For each genotype:
for (i in unique(filter(data_frame, (Genotype != "Col" & Genotype != "mpk5_17"))$Genotype)){
###We don't want to make comparisons of WT to itself - this could impact FDR correction
indiv_data <- data_frame%>%
group_by(Measurement, Experiment)%>%
mutate(p = (wilcox.test(NormalizedMeasuredValue[Genotype == i], NormalizedMeasuredValue[Genotype == "Col"], correct = FALSE, paired = FALSE))$p.value)%>%
###Add a column with each genotype
mutate(Genotype = i)%>%
select(Experiment, Genotype, Measurement, p)
###Add individual information to the main data frame
out <- rbind(as.data.frame(indiv_data), out)%>%distinct()
}
return(out)}
###Convert the normalized data from a tibble to a data frame
NormalizedData <- as.data.frame(NormalizedData)
### Apply the p_values function to the NormalizedData
p_values <- p_value(NormalizedData)
### Adjust the p-values using an FDR correction
adjusted_p_values <- p_values%>%
group_by(Measurement, Experiment)%>%
mutate(p_adj = p.adjust(p, method = 'fdr'))
### Add a column with a boolean indicating if the adjusted p-value is significant or not
adjusted_p_values$significant <- adjusted_p_values$p_adj < 0.05
### Convert this to a .csv file to share with Melissa:
write.csv(adjusted_p_values, file = "Fitness_PValues_OutliersRemoved.csv")
###Confirm that this p-value correction is actually doing what I think it is:
test <- filter(p_values, Experiment == "DEPI1",  Measurement == "SN")%>%
select(p, Genotype)
test$adjusted <- p.adjust(test$p, method = "fdr")
test
filter(adjusted_p_values, Experiment == "DEPI1", Measurement == "SN")
View(adjusted_p_values)
### Convert this to a .csv file to share with Melissa:
write.csv(adjusted_p_values, file = "Fitness_PValues_OutliersRemoved.csv")
test
test$p
p.adjust(test$p, method = "fdr")
corrected_p_value <- function(data_frame){
out <- data_frame%>%
###Group by experiment and measurement - we are correcting by the number of genotypes
group_by(Experiment, Measurement)%>%
mutate(p_adj = p.adjust(p, method = "fdr"))
out <- gather(out, type, p, p, p_adj)%>%arrange(genotype, time_point)
return(out)
}
corrected_p_value(NormalizedData)
corrected_p_value(p_values)
corrected_p_value <- function(data_frame){
out <- data_frame%>%
###Group by experiment and measurement - we are correcting by the number of genotypes
group_by(Experiment, Measurement)%>%
mutate(p_adj = p.adjust(p, method = "fdr"))
out <- gather(out, type, p, p, p_adj)%>%arrange(Genotype, Measurement)
return(out)
}
corrected_p_value(p_values)
corrected_p_value <- function(data_frame){
out <- data_frame%>%
###Group by experiment and measurement - we are correcting by the number of genotypes
group_by(Experiment, Measurement)%>%
mutate(p_adj = p.adjust(p, method = "fdr"))
return(out)
}
corrected_p_value(p_values)
P_value <- c(0.0001, 0.001, 0.006, 0.03, 0.095, 0.117, 0.234, 0.552, 0.751, 0.985)
p.adjust (P_values, method="bonferroni") ## [1] 0.001 0.010 0.060 0.300 0.950 1.000 1.000 1.000 1.000 1.000
p.adjust(P_value, method="bonferroni") ## [1] 0.001 0.010 0.060 0.300 0.950 1.000 1.000 1.000 1.000 1.000
###Confirm that this p-value correction is actually doing what I think it is:
test <- filter(p_values, Experiment == "DEPI1",  Measurement == "TSC")%>%
select(p, Genotype)
test$adjusted <- p.adjust(test$p, method = "fdr")
filter(adjusted_p_values, Experiment == "DEPI1", Measurement == "TSC")
### Adjust the p-values using an FDR correction
adjusted_p_values <- p_values%>%
group_by(Measurement, Experiment)%>%
mutate(p_adj = round(p.adjust(p, method = 'fdr'), 7))
###Confirm that this p-value correction is actually doing what I think it is:
test <- filter(p_values, Experiment == "DEPI1",  Measurement == "TSC")%>%
select(p, Genotype)
test$adjusted <- p.adjust(test$p, method = "fdr")
filter(adjusted_p_values, Experiment == "DEPI1", Measurement == "TSC")
filter(adjusted_p_values, Experiment == "DEPI1", Measurement == "TSC")$p_adj
test
test$p
P_value <- test$p
p.adjust(P_value, method="bonferroni")
p.adjust(P_value, method="FDR")
p.adjust(P_value, method="fdr")
library(stats)
P_value <- c(0.0001, 0.001, 0.006, 0.03, 0.095, 0.117, 0.234, 0.552, 0.751, 0.985)
p.adjust(P_value, method="bonferroni") ## [1] 0.001 0.010 0.060 0.300 0.950 1.000 1.000 1.000 1.000 1.000
P_value <- test$p
p.adjust(P_value, method="fdr")
P_value
adjusted_p_values
adjusted_p_values%>%
group_by(Experiment, Measurement)%>%
summarize(length(unique(p_adj)))
genotype_col <- c("A", "B", "C", "D", "E", "F")
terminal_go_col <- c(NA, NA, NA, "TERMINAL", "TERMINAL", NA)
data_frame <- cbind(genotype_col, terminal_go_col)
data_frame
data_frame <- as.data.frame(cbind(genotype_col, terminal_go_col))
data_frame
terminal_go <- list()
j <- 1
for (i in 1:nrow(data_frame)){
if (!is.na(data_frame[i,2])){
terminal_go[[j]] <- data_frame[i,1]
j <- j + 1
}
}
terminal_go
unlist(terminal_go)
unlist(terminal_go)
colnames(data_frame)
### Alternately:
library(dplyr)
data_frame%>%
filter(!is.na(terminal_go_col))
data_frame%>%
filter(!is.na(terminal_go_col))$genotype_col
(data_frame%>%
filter(!is.na(terminal_go_col)))$genotype_col
